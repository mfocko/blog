"use strict";(self.webpackChunkfi=self.webpackChunkfi||[]).push([[2917],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(96540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},90712:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"recursion/2023-08-17-pyramid-slide-down/bottom-up-dp","title":"Bottom-up DP solution","description":"Bottom-up DP solution of the Pyramid Slide Down.\\n","source":"@site/algorithms/04-recursion/2023-08-17-pyramid-slide-down/04-bottom-up-dp.md","sourceDirName":"04-recursion/2023-08-17-pyramid-slide-down","slug":"/recursion/pyramid-slide-down/bottom-up-dp","permalink":"/algorithms/recursion/pyramid-slide-down/bottom-up-dp","draft":false,"unlisted":false,"editUrl":"https://github.com/mfocko/blog/tree/main/algorithms/04-recursion/2023-08-17-pyramid-slide-down/04-bottom-up-dp.md","tags":[{"inline":true,"label":"java","permalink":"/algorithms/tags/java"},{"inline":true,"label":"dynamic-programming","permalink":"/algorithms/tags/dynamic-programming"},{"inline":true,"label":"bottom-up-dp","permalink":"/algorithms/tags/bottom-up-dp"}],"version":"current","lastUpdatedAt":1692230400000,"sidebarPosition":4,"frontMatter":{"id":"bottom-up-dp","slug":"/recursion/pyramid-slide-down/bottom-up-dp","title":"Bottom-up DP solution","description":"Bottom-up DP solution of the Pyramid Slide Down.\\n","tags":["java","dynamic-programming","bottom-up-dp"],"last_update":{"date":"2023-08-17T00:00:00.000Z"}},"sidebar":"autogeneratedBar","previous":{"title":"Top-down DP solution","permalink":"/algorithms/recursion/pyramid-slide-down/top-down-dp"},"next":{"title":"Red-Black Trees","permalink":"/algorithms/category/red-black-trees"}}');var i=t(74848),o=t(28453);const a={id:"bottom-up-dp",slug:"/recursion/pyramid-slide-down/bottom-up-dp",title:"Bottom-up DP solution",description:"Bottom-up DP solution of the Pyramid Slide Down.\n",tags:["java","dynamic-programming","bottom-up-dp"],last_update:{date:new Date("2023-08-17T00:00:00.000Z")}},r="Bottom-up dynamic programming",l={},d=[{value:"Time complexity",id:"time-complexity",level:2},{value:"Memory complexity",id:"memory-complexity",level:2}];function c(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",math:"math",mdxAdmonitionTitle:"mdxAdmonitionTitle",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",section:"section",semantics:"semantics",span:"span",strong:"strong",sup:"sup",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"bottom-up-dynamic-programming",children:"Bottom-up dynamic programming"})}),"\n",(0,i.jsxs)(n.p,{children:["If you try to think in depth about the top-down DP solution, you might notice\nthat the ",(0,i.jsx)(n.em,{children:"core"})," of it stands on caching the calculations that have been already\ndone on the lower \u201clevels\u201d of the pyramid. Our bottom-up implementation will be\nusing this fact!"]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["As I have said in the ",(0,i.jsx)(n.em,{children:"top-down DP"})," section, it is the easiest way to implement\nDP (unless the cached function has complicated parameters, in that case it might\nget messy)."]}),(0,i.jsx)(n.p,{children:"Bottom-up dynamic programming can be more effective, but may be more complicated\nto implement right from the beginning."})]}),"\n",(0,i.jsx)(n.p,{children:"Let's see how we can implement it:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public static int longestSlideDown(int[][] pyramid) {\n    // In the beginning we declare new array. At this point it is easier to just\n    // work with the one dimension, i.e. just allocating the space for the rows.\n    int[][] slideDowns = new int[pyramid.length][];\n\n    // Bottom row gets just copied, there's nothing else to do\u2026 It's the base\n    // case.\n    slideDowns[pyramid.length - 1] = Arrays.copyOf(pyramid[pyramid.length - 1],\n            pyramid[pyramid.length - 1].length);\n\n    // Then we need to propagate the found slide downs for each of the levels\n    // above.\n    for (int y = pyramid.length - 2; y >= 0; --y) {\n        // We start by copying the values lying in the row we're processing.\n        // They get included in the final sum and we need to allocate the space\n        // for the precalculated slide downs anyways.\n        int[] row = Arrays.copyOf(pyramid[y], pyramid[y].length);\n\n        // At this we just need to \u201cfetch\u201d the partial results from \u201cneighbours\u201d\n        for (int x = 0; x < row.length; ++x) {\n            // We look under our position, since we expect the rows to get\n            // shorter, we can safely assume such position exists.\n            int under = slideDowns[y + 1][x];\n\n            // Then we have a look to the right, such position doesn't have to\n            // exist, e.g. on the right edge, so we validate the index, and if\n            // it doesn't exist, we just assign minimum of the \u2039int\u203a which makes\n            // sure that it doesn't get picked in the \u2039Math.max()\u203a call.\n            int toRight = x + 1 < slideDowns[y + 1].length\n                            ? slideDowns[y + 1][x + 1]\n                            : Integer.MIN_VALUE;\n\n            // Finally we add the best choice at this point.\n            row[x] += Math.max(under, toRight);\n        }\n\n        // And save the row we've just calculated partial results for to the\n        // \u201ctable\u201d.\n        slideDowns[y] = row;\n    }\n\n    // At the end we can find our seeked slide down at the top cell.\n    return slideDowns[0][0];\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"I've tried to explain the code as much as possible within the comments, since it\nmight be more beneficial to see right next to the \u201coffending\u201d lines."}),"\n",(0,i.jsxs)(n.p,{children:["As you can see, in this approach we go from the other side",(0,i.jsx)(n.sup,{children:(0,i.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),", the bottom of\nthe pyramid and propagate the partial results up."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.mdxAdmonitionTitle,{children:["How is this different from the ",(0,i.jsx)(n.em,{children:"greedy"})," solution???"]}),(0,i.jsxs)(n.p,{children:["If you try to compare them, you might find a very noticable difference. The\ngreedy approach is going from the top to the bottom without ",(0,i.jsx)(n.strong,{children:"any"})," knowledge of\nwhat's going on below. On the other hand, bottom-up DP is going from the bottom\n(",(0,i.jsx)(n.em,{children:"DUH\u2026"}),") and ",(0,i.jsx)(n.strong,{children:"propagates"})," the partial results to the top. The propagation is\nwhat makes sure that at the top I don't choose the best ",(0,i.jsx)(n.strong,{children:"local"})," choice, but\nthe best ",(0,i.jsx)(n.strong,{children:"overall"})," result I can achieve."]})]}),"\n",(0,i.jsx)(n.h2,{id:"time-complexity",children:"Time complexity"}),"\n",(0,i.jsx)(n.p,{children:"Time complexity of this solution is rather simple. We allocate an array for the\nrows and then for each row, we copy it and adjust the partial results. Doing\nthis we get:"}),"\n",(0,i.jsx)(n.span,{className:"katex-display",children:(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{mathvariant:"script",children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mi,{children:"r"}),(0,i.jsx)(n.mi,{children:"o"}),(0,i.jsx)(n.mi,{children:"w"}),(0,i.jsx)(n.mi,{children:"s"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mn,{children:"2"}),(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(rows + 2n)"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"ro"}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.02691em"},children:"w"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"s"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord",children:"2"}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})]})]})}),"\n",(0,i.jsx)(n.p,{children:"Of course, this is an upper bound, since we iterate through the bottom row only\nonce."}),"\n",(0,i.jsx)(n.h2,{id:"memory-complexity",children:"Memory complexity"}),"\n",(0,i.jsxs)(n.p,{children:["We're allocating an array for the pyramid ",(0,i.jsx)(n.strong,{children:"again"})," for our partial results, so\nwe get:"]}),"\n",(0,i.jsx)(n.span,{className:"katex-display",children:(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{mathvariant:"script",children:"O"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"("}),(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n)"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(n.span,{className:"mopen",children:"("}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(n.span,{className:"mclose",children:")"})]})})]})}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:"If we were writing this in C++ or Rust, we could've avoided that, but not\nreally."}),(0,i.jsxs)(n.p,{children:["C++ would allow us to ",(0,i.jsx)(n.strong,{children:"copy"})," the pyramid rightaway into the parameter, so we\nwould be able to directly change it. However it's still a copy, even though we\ndon't need to allocate anything ourselves. It's just implicitly done for us."]}),(0,i.jsxs)(n.p,{children:["Rust is more funny in this case. If the pyramids weren't used after the call of\n",(0,i.jsx)(n.code,{children:"longest_slide_down"}),", it would simply ",(0,i.jsx)(n.strong,{children:"move"})," them into the functions. If they\nwere used afterwards, the compiler would force you to either borrow it, or\n",(0,i.jsx)(n.em,{children:"clone-and-move"})," for the function."]}),(0,i.jsx)(n.hr,{}),(0,i.jsxs)(n.p,{children:["Since we're doing it in Java, we get a reference to the ",(0,i.jsx)(n.em,{children:"original"})," array and we\ncan't do whatever we want with it."]})]}),"\n",(0,i.jsx)(n.h1,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.p,{children:["And we've finally reached the end. We have seen 4 different \u201csolutions\u201d",(0,i.jsx)(n.sup,{children:(0,i.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})})," of\nthe same problem using different approaches. Different approaches follow the\norder in which you might come up with them, each approach influences its\nsuccessor and represents the way we can enhance the existing implementation."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.admonition,{title:"source",type:"info",children:(0,i.jsxs)(n.p,{children:["You can find source code referenced in the text\n",(0,i.jsx)(n.a,{href:"pathname:///files/algorithms/recursion/pyramid-slide-down.tar.gz",children:"here"}),"."]})}),"\n","\n",(0,i.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,i.jsxs)(n.p,{children:["definitely not an RHCP reference ","\ud83d\ude09 ",(0,i.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,i.jsxs)(n.p,{children:["one was not correct, thus the quotes ",(0,i.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);