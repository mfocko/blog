"use strict";(self.webpackChunkfi=self.webpackChunkfi||[]).push([[33],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(96540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}},64951:e=>{e.exports=JSON.parse('{"permalink":"/blog/aoc-2025/third-03","editUrl":"https://github.com/mfocko/blog/tree/main/blog/aoc-2025/03-third.md","source":"@site/blog/aoc-2025/03-third.md","title":"Final third of Advent of Code \u201825 in Java","description":"Final third of Advent of Code \u201825.","date":"2025-12-14T03:14:00.000Z","tags":[{"inline":true,"label":"advent-of-code","permalink":"/blog/tags/advent-of-code"},{"inline":true,"label":"advent-of-code-2025","permalink":"/blog/tags/advent-of-code-2025"},{"inline":true,"label":"java","permalink":"/blog/tags/java"}],"readingTime":7.265,"hasTruncateMarker":true,"authors":[{"name":"Matej Focko","email":"me+blog@mfocko.xyz","title":"a.k.a. @mf","url":"https://gitlab.com/mfocko","imageURL":"https://github.com/mfocko.png","key":"mf","page":null}],"frontMatter":{"title":"Final third of Advent of Code \u201825 in Java","description":"Final third of Advent of Code \u201825.","date":"2025-12-14T03:14","slug":"aoc-2025/third-03","authors":"mf","tags":["advent-of-code","advent-of-code-2025","java"],"hide_table_of_contents":false},"unlisted":false,"nextItem":{"title":"Second third of Advent of Code \u201825 in Java","permalink":"/blog/aoc-2025/third-02"}}')},65947:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var a=n(64951),i=n(74848),s=n(28453);const o={title:"Final third of Advent of Code \u201825 in Java",description:"Final third of Advent of Code \u201825.",date:"2025-12-14T03:14",slug:"aoc-2025/third-03",authors:"mf",tags:["advent-of-code","advent-of-code-2025","java"],hide_table_of_contents:!1},r=void 0,l={authorsImageUrls:[void 0]},h=[{value:"Day 9: Movie Theater",id:"day-9-movie-theater",level:2},{value:"Changes to library",id:"changes-to-library",level:3},{value:"\u201cQueue consumer\u201d",id:"queue-consumer",level:4},{value:"<code>pairs()</code> and helpers",id:"pairs-and-helpers",level:4},{value:"Day 10: Factory",id:"day-10-factory",level:2},{value:"Day 11: Reactor",id:"day-11-reactor",level:2},{value:"Day 12: Christmas Tree Farm",id:"day-12-christmas-tree-farm",level:2},{value:"Final changes to the library",id:"final-changes-to-the-library",level:3},{value:"<code>Parser.of()</code>",id:"parserof",level:4},{value:"Summary",id:"summary",level:2},{value:"Advent of Code itself",id:"advent-of-code-itself",level:3},{value:"Java",id:"java",level:3},{value:"Toolchain",id:"toolchain",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Let's go through the final third of this year\u2019s ",(0,i.jsx)(t.a,{href:"https://adventofcode.com",children:(0,i.jsx)(t.em,{children:"Advent of Code"})}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"day-9-movie-theater",children:(0,i.jsx)(t.a,{href:"https://adventofcode.com/2025/day/9",children:"Day 9: Movie Theater"})}),"\n",(0,i.jsx)(t.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(t.p,{children:"Covering the floor with red tiles\u2026 and maybe also some green in case it would\nbe too simple."})}),"\n",(0,i.jsx)(t.p,{children:"First part was pretty easy, very simple thing to literally brute-force. On the\nother hand\u2026 the second part was a bit worse."}),"\n",(0,i.jsx)(t.p,{children:"My idea was a pretty primitive one, just do the same thing as in the first part\nand filter out the options that are not valid."}),"\n",(0,i.jsxs)(t.p,{children:["Turns out that the process of deciding what is and what is not valid ",(0,i.jsx)(t.strong,{children:"is"})," the\nproblem."]}),"\n",(0,i.jsx)(t.p,{children:"In the end I have managed to refactor the solution into:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"@Override\nLong part1() {\n  return getBiggestTriangle(_r -> true);\n}\n\n@Override\nLong part2() {\n  return getBiggestTriangle(this::isValidRectangle);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"changes-to-library",children:"Changes to library"}),"\n",(0,i.jsx)(t.h4,{id:"queue-consumer",children:"\u201cQueue consumer\u201d"}),"\n",(0,i.jsxs)(t.p,{children:["This was the second day when I had to utilize the ",(0,i.jsx)(t.em,{children:"heap consumer"}),(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-1-8e748b",id:"user-content-fnref-1-8e748b","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),", so I have\ndecided to factor it out to the library. Since the method itself accepts\nan object implementing ",(0,i.jsx)(t.code,{children:"Queue<T>"})," interface, I have renamed it\nto ",(0,i.jsx)(t.code,{children:"consumeQueue()"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"/**\n * Creates a stream that consumes elements from a queue.\n *\n * @param <T> the type of elements in the queue\n * @param queue the queue to consume elements from\n * @return a stream of elements from the queue, in the order they are polled,\n *     terminating when the queue becomes empty (when {@code poll()} returns\n *     {@code null})\n */\npublic static <T> Stream<T> consumeQueue(Queue<T> queue) {\n  return Stream\n    .iterate(queue.poll(), _it -> queue.poll())\n    .takeWhile(it -> it != null);\n}\n"})}),"\n",(0,i.jsxs)(t.h4,{id:"pairs-and-helpers",children:[(0,i.jsx)(t.code,{children:"pairs()"})," and helpers"]}),"\n",(0,i.jsx)(t.p,{children:"For iterating over the possible choices, in this puzzle, I had to generate all\npossible pairs from an input. Overall it made sense to just implement a method\nthat takes a stream and generates the pairs:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"public static <T> Stream<Pair<T, T>> pairs(Supplier<Stream<T>> xs) {\n  return zip(indices().boxed(), xs.get())\n      .flatMap(p ->\n        xs.get()\n          .skip(p.first() + 1)\n          .map(y -> Pair.of(p.second(), y)));\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["However, in the end, I needed some other helpers to get there\u2026 Namely it was\neasier to implement infinite ",(0,i.jsx)(t.code,{children:"indices()"})," rather then iterate the stream twice."]}),"\n",(0,i.jsxs)(t.p,{children:["Also you can notice that ",(0,i.jsx)(t.code,{children:"pairs()"})," gets passed a ",(0,i.jsx)(t.code,{children:"Supplier<Stream<T>>"})," rather\nthan the stream itself. That's coming from the fact that streams can be iterated\nthrough only once, so I need to have a functional object that ",(0,i.jsx)(t.em,{children:"generates"})," a new\nstream each time I need it."]}),"\n",(0,i.jsx)(t.h2,{id:"day-10-factory",children:(0,i.jsx)(t.a,{href:"https://adventofcode.com/2025/day/10",children:"Day 10: Factory"})}),"\n",(0,i.jsx)(t.admonition,{title:"tl;dr",type:"info",children:(0,i.jsxs)(t.p,{children:["Pressing buttons to light up christmas lights in specific configuration. Until\nyou realize it's not about the ",(0,i.jsx)(t.em,{children:"on"})," and ",(0,i.jsx)(t.em,{children:"off"}),", but about the ",(0,i.jsx)(t.em,{children:"\u201cjoltage\u201d"}),"\u2026"]})}),"\n",(0,i.jsxs)(t.p,{children:["This day\u2026 was ",(0,i.jsx)(t.strong,{children:"a scam"}),". For the first part you had to light up lights on the\nmachine in a specific configuration. Part of the input were buttons that contain\na list of lights that get toggled with each press."]}),"\n",(0,i.jsx)(t.p,{children:"A lot of people chose to go with integral representation of the lights and\nbuttons and then just applying simple XOR."}),"\n",(0,i.jsx)(t.p,{children:"I didn't try to simplify the inputs, so I've ended up with lists (or sets) of\nintegers and used BFS for solving the first part."}),"\n",(0,i.jsx)(t.p,{children:"And\u2026 second part is where the fun starts."}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsx)(t.p,{children:"Input consisted of multitude of machines where each one is represented by:"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"indicator lights"})," - used in part 1"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"buttons"})," - that toggle indicator lights"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.em,{children:"joltage"})," - used in part 2"]}),"\n"]})]}),"\n",(0,i.jsx)(t.p,{children:"For the part 2 you have to find minimal number of presses to raise joltage to\nthe seeked joltage\u2026"}),"\n",(0,i.jsxs)(t.p,{children:["The search space for this problem is enormous\u2026 I've tried a very na\xefve approach\nof preprocessing the buttons for each machine in such order that narrows the\nsearch space. This approach was ",(0,i.jsx)(t.em,{children:"relatively"})," effective, but not effective enough\n","\ud83d\ude04"," To cut the story short, I've ended up with 97 % of the input processed,\nbut got stuck there for 3.5 hours after which I killed it."]}),"\n",(0,i.jsx)(t.p,{children:"Once the solution has been running for about 30 minutes, I have started to pick\naway here and there to optimize bit by bit. And it was pretty effective! To sum\nit up:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["I had a method to generate counters (i.e., ",(0,i.jsx)(t.code,{children:"long[]"})," of zeros); in the initial\nsolution I used ",(0,i.jsx)(t.code,{children:"range().map().toArray()"}),", switched it to simple ",(0,i.jsx)(t.code,{children:"new long[]"})]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"for read-only operations, where possible, I've switched to parallel streams\ninstead of sequential"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"changed the strategy of exploring the search space; instead of going from\nminimum needed to maximum possible presses of a button, I've turned it around\nand went from maximum possible to minimum needed, which prunes the unreachable\nbranches quicker"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"and finally the recursive calls that get called for each button press\u2026\nfor each of this calls I create a separate \u201cgoal\u201d joltage the search is\nsupposed to address, that way I can paralelize those too"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"And this has gotten me from 3.5 hours (still missing the last 4 results) to 6\nminutes."}),"\n",(0,i.jsx)(t.h2,{id:"day-11-reactor",children:(0,i.jsx)(t.a,{href:"https://adventofcode.com/2025/day/11",children:"Day 11: Reactor"})}),"\n",(0,i.jsx)(t.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(t.p,{children:"Counting possible paths through a network of devices."})}),"\n",(0,i.jsxs)(t.p,{children:["Relatively easy way to solve this. Can be done recursively, it's basically just\ngoing through the graph, trying to find a way to the ",(0,i.jsx)(t.em,{children:"goal"}),". And at the same\ntime counting how many ways there are\u2026"]}),"\n",(0,i.jsxs)(t.p,{children:["I have to admit that I ",(0,i.jsx)(t.strong,{children:"did not"})," expect to get burnt at this Java-specific\nthing on the 11th day ","\ud83d\ude04"," I've been teaching at ",(0,i.jsx)(t.em,{children:"Intro to programming"})," for\nyears that sometimes it's not a good idea to use niche features specific only to\none or two languages, yet\u2026 At first I didn't realize at all that"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"if (from == sink) {\n  return 1l;\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"does something totally different than"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-java",children:"if (from.equals(sink)) {\n  return 1l;\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"=="})," compares references, and, as opposed to other languages like C++ or C#,\ncannot be overriden. However I noticed this mistake rather quickly, cause the\ngraph traversal doesn't terminate, duh\u2026"]}),"\n",(0,i.jsx)(t.p,{children:"I expected to make this mistake during the beginning, not at the second to last\nday."}),"\n",(0,i.jsx)(t.h2,{id:"day-12-christmas-tree-farm",children:(0,i.jsx)(t.a,{href:"https://adventofcode.com/2025/day/12",children:"Day 12: Christmas Tree Farm"})}),"\n",(0,i.jsx)(t.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(t.p,{children:"Puzzle about tiling problem. However the challenge input is a bit more simpler\nthan the complicated sample\u2026"})}),"\n",(0,i.jsx)(t.p,{children:"At the first look, the problem looks extremely annoying. And it kinda is\u2026 The\nfun thing is that it is possible to solve simply by expecting a bit more area,\nas a buffer, to be occupied by the tiles and simply checking whether it could\nfit."}),"\n",(0,i.jsx)(t.p,{children:"What's even more funny is the fact that the provided sample is quite picky about\nthis, i.e., you need to account for 20 % buffer to make it pass. However the\nchallenge input\u2026 that works without any buffer\u2026"}),"\n",(0,i.jsx)(t.h3,{id:"final-changes-to-the-library",children:"Final changes to the library"}),"\n",(0,i.jsx)(t.h4,{id:"parserof",children:(0,i.jsx)(t.code,{children:"Parser.of()"})}),"\n",(0,i.jsxs)(t.p,{children:["I've tried to simplify the parser a bit, so I introduced a method ",(0,i.jsx)(t.code,{children:"Parser.of()"}),"\nto be able to construct instances of parsers without the need to use ",(0,i.jsx)(t.code,{children:"new"})," and\n",(0,i.jsx)(t.code,{children:"<>"})," for type inference of the resulting types to be produced by parsing\u2026"]}),"\n",(0,i.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Finished advent calendar :smile:",src:n(84644).A+"",width:"2248",height:"1580"})}),"\n",(0,i.jsx)(t.h3,{id:"advent-of-code-itself",children:"Advent of Code itself"}),"\n",(0,i.jsx)(t.p,{children:"I have a bit of mixed feelings. Thankfully, this year, there was only one day\nthat was particularly obnoxious with regards to parsing."}),"\n",(0,i.jsxs)(t.p,{children:["There were only 12 days instead of the usual 25. I have tried to solve all days\nat 6am (CET) and\u2026 I'm not very used to writing Java at 6am to be honest ","\ud83d\ude04","\nSo I definitely don't mind an early end on that front ","\ud83d\udc40"," Though it is quite\nknown that the complexity of the tasks grows towards the end of the AoC, so this\nyear might seem a bit ",(0,i.jsx)(t.em,{children:"easy-going"}),"? I can understand the need for a bit\nof a challenge."]}),"\n",(0,i.jsx)(t.h3,{id:"java",children:"Java"}),"\n",(0,i.jsx)(t.p,{children:"Even though Java is the first language I've learnt and also learnt to hate\nfurther on, it was quite pleasent experience in my opinion. I confess to abusing\nthe streams and other FP-like \u201cfeatures\u201d."}),"\n",(0,i.jsxs)(t.p,{children:["I definitely hate the boilerplate for each day\u2026 but looking back at it, it makes\nit quite customizable, so, for example, in ",(0,i.jsx)(t.a,{href:"/blog/aoc-2025/third-02#day-8-playground",children:"day #8"})," I was able to simply add the\nconstraint (which was different for sample and challenge input) to constructor\nand it allowed pretty easy testing and computing the challenge at the same time."]}),"\n",(0,i.jsx)(t.h3,{id:"toolchain",children:"Toolchain"}),"\n",(0,i.jsx)(t.p,{children:"I didn't feel comfortable working with either IDEA or VSCode. They each have\ntheir own quirks, e.g., not working completion (which is definitely helpful with\nstreams and data structures), or issues running the puzzles in a way that would\nfit my workflow."}),"\n",(0,i.jsx)(t.p,{children:"OTOH it was a quite pleasant experience with testing (apart from constructors in\nclasses that are not instantiated) and also doc-generation. Though I feel that\njavadoc is still\u2026 bit obscure format for me."}),"\n","\n",(0,i.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{id:"user-content-fn-1-8e748b",children:["\n",(0,i.jsxs)(t.p,{children:["the method I have implementing for converting a min-heap into a stream ",(0,i.jsx)(t.a,{href:"#user-content-fnref-1-8e748b","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},84644:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/calendar-5bf14f0b5491b4f8d192afa33ea4e5a6.png"}}]);