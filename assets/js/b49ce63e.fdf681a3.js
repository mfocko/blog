"use strict";(self.webpackChunkfi=self.webpackChunkfi||[]).push([[1020],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var a=t(96540);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}},32028:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var a=t(79191),i=t(74848),r=t(28453);const o={title:"Second third of Advent of Code \u201825 in Java",description:"Second third of Advent of Code \u201825.",date:"2025-12-10T03:14",slug:"aoc-2025/third-02",authors:"mf",tags:["advent-of-code","advent-of-code-2025","java"],hide_table_of_contents:!1},s=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Day 5: Cafeteria",id:"day-5-cafeteria",level:2},{value:"Parsing intermezzo #1",id:"parsing-intermezzo-1",level:3},{value:"Functional interface",id:"functional-interface",level:4},{value:"Day 6: Trash Compactor",id:"day-6-trash-compactor",level:2},{value:"Day 7: Laboratories",id:"day-7-laboratories",level:2},{value:"Changes to library",id:"changes-to-library",level:3},{value:"<code>Pair.of()</code>",id:"pairof",level:4},{value:"Day 8: Playground",id:"day-8-playground",level:2},{value:"Changes to library",id:"changes-to-library-1",level:3},{value:"Euclidean distance",id:"euclidean-distance",level:4}];function h(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Let's go through the second third of this year\u2019s ",(0,i.jsx)(n.a,{href:"https://adventofcode.com",children:(0,i.jsx)(n.em,{children:"Advent of Code"})}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"day-5-cafeteria",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2025/day/5",children:"Day 5: Cafeteria"})}),"\n",(0,i.jsxs)(n.admonition,{title:"tl;dr",type:"info",children:[(0,i.jsx)(n.p,{children:"Ranges??? AGAIN??? Bit more annoying than the last time though. For the part 1\nyou check how many items of your \u201cshopping list\u201d fall into any of the ranges."}),(0,i.jsx)(n.p,{children:"And for the part 2, you get to find how many IDs are covered by those ranges."})]}),"\n",(0,i.jsxs)(n.p,{children:["Pretty eazy to solve, given that you chose a good representation for the input.\nEven ",(0,i.jsx)(n.em,{children:"spotless"})," thought it's a good idea to keep the solution for part 1 on one\nline ","\ud83d\ude09"]}),"\n",(0,i.jsxs)(n.p,{children:["I have also tried using the IDEA instead of the VSCode, but\u2026 I've hit different\nissues with the IDE ","\ud83e\udd26\u200d\u2642\ufe0f"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"VSCode has trouble with the source dependencies defined by gradle and that's\nwhy any completion or type inference in the editor fails miserably :)"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["as for the IDEA\u2026 type inference and completion works, but it has the same\nproblem except for the fact that it \xbbdisassembles\xab compiled ",(0,i.jsx)(n.code,{children:"*.class"})," files of\nthe library and that's how it gets type inference and completion to work, but\u2026"]}),"\n",(0,i.jsxs)(n.p,{children:["still no javadoc and on top of that running the \u201capp\u201d is problematic, as I\nhave not been able to get any output from the app in case it fails with an\nexception ","\ud83d\ude04"," not even with ",(0,i.jsx)(n.code,{children:"--stacktrace"}),"\u2026 the output just vanishes"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"So in the end I've decided to revert back to the VSCode, as running the app is\na bit more comfortable than fighting the runner in IDEA."}),"\n",(0,i.jsx)(n.h3,{id:"parsing-intermezzo-1",children:"Parsing intermezzo #1"}),"\n",(0,i.jsxs)(n.p,{children:["This is the day when I decided to improve the parsing situation. From the\nprevious years and other languages I've noticed some patterns, with Java\u2026 I did\nnot notice any ","\ud83d\udc40"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["For Rust there's a ",(0,i.jsx)(n.code,{children:"FromStr"})," trait that allows you to use ",(0,i.jsx)(n.code,{children:"T::from_str()"})," that\ncan either return the parsed structure or an error."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["In Kotlin there was a funny \u201cconvention\u201d of extending strings with a method\n",(0,i.jsx)(n.code,{children:".toSomething()"})," which would allow you to do: ",(0,i.jsx)(n.code,{children:'"1,2".toPoint()'})," or something\nsimilar."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"In C# there's a pretty good construct of"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:"public static bool TryParse(string? s, out T result);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It seems a bit complex, but basically it allows you to get a result of the\nconversion as a return value (the ",(0,i.jsx)(n.code,{children:"bool"})," indicates success or failure) and at\nthe same time you can populate an ",(0,i.jsx)(n.code,{children:"out"})," variable with the parsed data. Overall\nit can be combined into:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cs",children:'var stringRepresentation = "1,2";\nif (Point.TryParse(stringRepresentation, out var point)) {\n  Console.WriteLine($"Parsed point of x={point.x} y={point.y}");\n} else {\n  Console.WriteLine($"Failed to parse: \u2039{stringRepresentation}\u203a");\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["As I have not been able to find any convention about that in Java, apart from\nthe parsing method for primitive data types: ",(0,i.jsx)(n.code,{children:"Integer.parseInt()"}),"\nor ",(0,i.jsx)(n.code,{children:"Long.parseLong()"}),". I have decided to come up with something suitable for AoC\nmyself:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public abstract class StringParser<T> {\n  public abstract T from(String s);\n\n  public Stream<T> from(Stream<String> xs) {\n    return xs.map(it -> from(it));\n  }\n\n  public Stream<T> from(List<String> xs) {\n    return from(xs.stream());\n  }\n\n  public Stream<T> from(String[] xs) {\n    return from(Arrays.stream(xs));\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"We have a few adapters over the unimplemented method, so it is easy to parse\nmultiple values at once. And one abstract method that defines parsing from\na single string."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Of course, it is also possible to create anonymous objects of ",(0,i.jsx)(n.code,{children:"StringParser<T>"}),"\nthat don't have to be named, they just need to implement that ",(0,i.jsx)(n.code,{children:".from()"})," method."]})}),"\n",(0,i.jsx)(n.p,{children:"During the testing I have found out that\u2026 it works well, but at the same time is\nquite verbose:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testParse() {\n  try (var input = new Input(69, "regression")) {\n    char[][] map =\n        new char[][] {\n          "123049575901212312312313".toCharArray(),\n          "123123130999555554444433".toCharArray(),\n          "000111100022222330000000".toCharArray(),\n        };\n    assertArrayEquals(\n        map,\n        input.parse(\n            new StringParser<char[][]>() {\n              @Override\n              public char[][] from(String s) {\n                return Arrays.stream(s.split("\\n"))\n                    .map(row -> row.trim().toCharArray())\n                    .toArray(char[][]::new);\n              }\n            }));\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As you can tell there's a lot of boilerplate still\u2026 And that's where I got\ninspired by the higher-order functions in Java. Even though they accept\n\u201ccallable\u201d objects, you don't that much boilerplate around them. And the reason\nwhy you don't is a ",(0,i.jsx)(n.em,{children:"functional interface"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"functional-interface",children:"Functional interface"}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Functional interface is a concept of an interface that has ",(0,i.jsx)(n.strong,{children:"exactly"})," one\nabstract method. Since there's exactly one method, you can create an instance\nof a functional interface with lambda, method or constructor reference."]})}),"\n",(0,i.jsxs)(n.p,{children:["Given this annotation, I have converted ",(0,i.jsx)(n.code,{children:"StringParser<T>"})," into:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@FunctionalInterface\npublic interface StringParser<T> {\n  T from(String s);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"And to be able to utilize the other methods, if needed:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class Parser<T> implements StringParser<T> {\n  private final StringParser<T> parser;\n\n  public Parser(StringParser<T> parser) {\n    if (parser == null) {\n\t      throw new IllegalArgumentException("\u2039parser\u203a cannot be null");\n    }\n    this.parser = parser;\n  }\n\n  public T from(String s) {\n    return parser.from(s);\n  }\n\n  public Stream<T> from(Stream<String> xs) {\n    return xs.map(it -> from(it));\n  }\n\n  public Stream<T> from(List<String> xs) {\n    return from(xs.stream());\n  }\n\n  public Stream<T> from(String[] xs) {\n    return from(Arrays.stream(xs));\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"And the parser above can now be written as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Test\npublic void testParse() {\n  try (var input = new Input(69, "regression")) {\n    char[][] map =\n        new char[][] {\n          "123049575901212312312313".toCharArray(),\n          "123123130999555554444433".toCharArray(),\n          "000111100022222330000000".toCharArray(),\n        };\n    assertArrayEquals(\n        map,\n        input.parse(\n            s -> {\n              return Arrays.stream(s.split("\\n"))\n                  .map(row -> row.trim().toCharArray())\n                  .toArray(char[][]::new);\n            }));\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"day-6-trash-compactor",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2025/day/6",children:"Day 6: Trash Compactor"})}),"\n",(0,i.jsxs)(n.p,{children:["For this day we also have a photo from this year's setup at 6am ","\ud83d\ude09"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(64138).A+"",width:"1920",height:"1440"})}),"\n",(0,i.jsxs)(n.admonition,{title:"tl;dr",type:"info",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Advent of Parsing"}),", here we go! Part 1? Easy! Part 2? You get to pay for your\nparsing decisions in the part 1 :)"]}),(0,i.jsx)(n.p,{children:"Whole day is about a simple addition, or multiplication, of numbers in a column\nas you have definitely learned at the elementary schoold, but the part 2 shows\nyou that sometimes not everything is aligned as it's supposed to be\u2026"})]}),"\n",(0,i.jsxs)(n.p,{children:["And the old ",(0,i.jsx)(n.em,{children:"Advent of Parsing"})," is back\u2026"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"123 328  51 64 \n 45 64  387 23 \n  6 98  215 314\n*   +   *   +  \n"})}),"\n",(0,i.jsx)(n.p,{children:"Surely that whitespace around the numbers has no meaning, right? RIGHT?!?!"}),"\n",(0,i.jsx)(n.admonition,{title:"Spoiler alert",type:"danger",children:(0,i.jsxs)(n.p,{children:["It does\u2026 ",(0,i.jsx)(n.em,{children:"sigh"})]})}),"\n",(0,i.jsx)(n.p,{children:"Part 1 was relatively OK, just treat the last row as special, since it has\noperators and then for the other rows, split on whitespace and trim all other\nwhitespace."}),"\n",(0,i.jsx)(n.admonition,{title:"N.B.",type:"tip",children:(0,i.jsxs)(n.p,{children:["This was the day when my column iterator came in handy ","\ud83c\udf89"]})}),"\n",(0,i.jsxs)(n.p,{children:["As for the second part\u2026 that was not fun\u2026 had to rewrite almost all of the\nparsing. After making up an algorithm for handling the different representation\nof numbers (one column of ",(0,i.jsx)(n.strong,{children:"digits"})," being a number), and still getting wrong\nresults, I noticed that the alignment from both sides matters ","\ud83e\udd26\u200d\u2642\ufe0f"]}),"\n",(0,i.jsx)(n.p,{children:"However after the refactoring I got to a solution that accepts an operator and\na stream of numbers, so it boiled down to one function doing \u201cthe math\u201d and the\ntwo other (for each part) just passing a stream of numbers to it\u2026"}),"\n",(0,i.jsx)(n.h2,{id:"day-7-laboratories",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2025/day/7",children:"Day 7: Laboratories"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Splitting beams, until\u2026 you're splitting timelines :)"})}),"\n",(0,i.jsx)(n.p,{children:"Part 1 was not the easiest to comprehend when reading it for the first time.\nHowever if you get what you're supposed to do (and do not try to be smart about\nit), it is rather easy to solve."}),"\n",(0,i.jsx)(n.p,{children:"During the refactoring I've done several improvements, though\u2026 I have to admit\nthat in the end I might've overdone it a bit and it's kinda\u2026\xa0perverted."}),"\n",(0,i.jsx)(n.p,{children:"Since you're splitting beams on the splitters, the initial solution contained\na following bit of copy-paste:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"if (manifold[y][x - 1] == '.') {\n  // \u2026\n}\n\nif (manifold[y][x + 1] == '.') {\n  // \u2026\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Which I have managed to refactor into:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"for (int dx : new int[] {-1, 1}) {\n  if (manifold[y][x + dx] != '.') {\n    continue;\n  }\n  // \u2026\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And I couldn't stop there\u2026 I have also decided to use ",(0,i.jsx)(n.code,{children:"switch"}),"-expressions where\npossible. For example the computation of possible timelines from part 2:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"dp[y][x] =\n    switch (manifold[y][x]) {\n      case 'S', '|' -> get(y + 1, x);\n      case '^' -> get(y, x - 1) + get(y, x + 1);\n      default -> throw new IllegalStateException(\"no need to evaluate empty cells\");\n    };\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Furthermore I have decided to convert the ",(0,i.jsx)(n.code,{children:"for-each"}),"-loop above into a stream\u2026\nand once I got a knack for it\u2026 I have created an adapter for consuming the queue\nas a stream ","\ud83e\udd26\u200d\u2642\ufe0f"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"private <T> Stream<T> consumeHeap(Queue<T> heap) {\n  return Stream.iterate(\n      heap.poll(),\n     _it -> heap.poll()\n    )\n    .takeWhile(it -> it != null);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Fun thing is, since the stream is lazily evaluated, you can add more elements\nto the heap while iterating through it. So it basically can work as\na ",(0,i.jsx)(n.code,{children:"for-each"}),"-loop through the heap as long as there's something in it."]}),"\n",(0,i.jsx)(n.h3,{id:"changes-to-library",children:"Changes to library"}),"\n",(0,i.jsx)(n.h4,{id:"pairof",children:(0,i.jsx)(n.code,{children:"Pair.of()"})}),"\n",(0,i.jsxs)(n.p,{children:["For the cases where it is possible to use type inference, I have stolen a helper\nfrom ",(0,i.jsx)(n.a,{href:"https://github.com/S3MU1L/advent-of-code-2025",children:"@semuil"})," to avoid unnecessary clutter, i.e., ",(0,i.jsx)(n.code,{children:"new"})," and ",(0,i.jsx)(n.code,{children:"<>"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"new Pair<>(x, y)\n// turns into\nPair.of(x, y)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"day-8-playground",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2025/day/8",children:"Day 8: Playground"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Substituting for electricians and going through the piles of cables\u2026"})}),"\n",(0,i.jsx)(n.p,{children:"The core of this puzzle was to repeateadly connect the closest boxes together."}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Probably the most appropriate way to approach this problem is to use union-find.\nSince it's something I'd include in the library, I've decided to just use\nmin-heap and go from there."})}),"\n",(0,i.jsx)(n.p,{children:"Now the first part was relatively easy to solve, though the abstraction hurt\na bit here. More specifically we want to partition the boxes into subsets in\nsuch order that the one with the closest distance are together in one subset."}),"\n",(0,i.jsx)(n.p,{children:"So\u2026 you need to be able to track to which partition each box belongs. Therefore\nthe easiest solution was to simply keep indices in the heap and keep an array\nwith \u201cmarks\u201d for each partition."}),"\n",(0,i.jsxs)(n.p,{children:["And this is where I screwed up royally and was not able to find my mistake for\nsome time ","\ud83d\ude04"]}),"\n",(0,i.jsx)(n.p,{children:"To sum up what we're going to do:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"We pick the closest two boxes from the queue, if they're already in the same\npartition, we can safely ignore and proceed. Otherwise we need to merge the\npartitions into one."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This should be achieved with the following code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"consumeHeap(queue)\n  .limit(maxConnections)\n  .forEach(\n    it -> {\n      var a = it.first();\n      var b = it.second();\n\n      if (mapping[a] == mapping[b]) {\n        return;\n      }\n\n      for (var i = 0; i < mapping.length; ++i) {\n        if (mapping[i] == mapping[b]) {\n          mapping[i] = mapping[a];\n        }\n      }\n    });\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Except for one smaller issue\u2026 that I was not able to find for the longest time\npossible ","\ud83d\ude04"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"//      vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n        if (mapping[i] == mapping[b]) {\n          mapping[i] = mapping[a];\n        }\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"for"}),"-loop is supposed to take each box from the same partition as the latter\nbox from the two closest ones and move it to the partition of the first box. And\nit does that\u2026 but once it wipes the mark of the original parition, cause it is\nequal to itself (duh\u2026), we lose the track and everything from that point onwards\nstays in the original partition."]}),"\n",(0,i.jsx)(n.p,{children:"That was a rookie and quite stupid mistake that cost a lot of time\u2026"}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["Fun fact, if the indices were evaluated using the strict evaluation strategy,\nthe overwriting would happen afterwards and therefore this problem could've been\navoided. But\u2026 they're not, it's a ",(0,i.jsx)(n.code,{children:"for"}),"-loop with side effects."]}),(0,i.jsx)(n.p,{children:"And, even if, I used the streams, the stream of indices would've been evaluated\nlazily."})]}),"\n",(0,i.jsx)(n.p,{children:"As both parts are quite similar, I have managed to refactor the common logic\ninto:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"@Override\nLong part1() {\n  consumeHeap(queue).limit(maxConnections).forEach(this::connect);\n  // construct the answer to part 1\n}\n\n@Override\nLong part2() {\n  Pair<Integer, Integer> it = null;\n  while (sizes.size() != 1) {\n    it = queue.poll();\n    connect(it);\n  }\n  // construct the answer to part 2\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"changes-to-library-1",children:"Changes to library"}),"\n",(0,i.jsx)(n.h4,{id:"euclidean-distance",children:"Euclidean distance"}),"\n",(0,i.jsxs)(n.p,{children:["Since the ",(0,i.jsx)(n.em,{children:"Euclidean distance"})," used in this puzzle seemed handy, I moved it out\nto the library. Funnily as part of the optimization I've used the squared\nEuclidean distance throughout this puzzle, so the interface includes both actual\ndistance and the distance squared."]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},64138:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/setup-b3368fdacc469985b433d916e396f50e.png"},79191:e=>{e.exports=JSON.parse('{"permalink":"/blog/aoc-2025/third-02","editUrl":"https://github.com/mfocko/blog/tree/main/blog/aoc-2025/02-third.md","source":"@site/blog/aoc-2025/02-third.md","title":"Second third of Advent of Code \u201825 in Java","description":"Second third of Advent of Code \u201825.","date":"2025-12-10T03:14:00.000Z","tags":[{"inline":true,"label":"advent-of-code","permalink":"/blog/tags/advent-of-code"},{"inline":true,"label":"advent-of-code-2025","permalink":"/blog/tags/advent-of-code-2025"},{"inline":true,"label":"java","permalink":"/blog/tags/java"}],"readingTime":10.01,"hasTruncateMarker":true,"authors":[{"name":"Matej Focko","email":"me+blog@mfocko.xyz","title":"a.k.a. @mf","url":"https://gitlab.com/mfocko","imageURL":"https://github.com/mfocko.png","key":"mf","page":null}],"frontMatter":{"title":"Second third of Advent of Code \u201825 in Java","description":"Second third of Advent of Code \u201825.","date":"2025-12-10T03:14","slug":"aoc-2025/third-02","authors":"mf","tags":["advent-of-code","advent-of-code-2025","java"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Final third of Advent of Code \u201825 in Java","permalink":"/blog/aoc-2025/third-03"},"nextItem":{"title":"First third of Advent of Code \u201825 in Java","permalink":"/blog/aoc-2025/third-01"}}')}}]);