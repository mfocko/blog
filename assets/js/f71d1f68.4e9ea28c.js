"use strict";(self.webpackChunkfi=self.webpackChunkfi||[]).push([[6069],{13068:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>h});var s=t(85893),o=t(11151);const i={title:"Mixed feelings on Rust",description:"Discussing my mixed feelings about the Rust language.\n",date:new Date("2024-01-28T00:00:00.000Z"),authors:[{key:"mf",title:"a.k.a. passionate language hater"}],tags:["rust","memory safety","cult","hype"],hide_table_of_contents:!1},a=void 0,r={permalink:"/blog/2024/01/28/rust-opinion",editUrl:"https://github.com/mfocko/blog/tree/main/blog/2024-01-28-rust-opinion.md",source:"@site/blog/2024-01-28-rust-opinion.md",title:"Mixed feelings on Rust",description:"Discussing my mixed feelings about the Rust language.\n",date:"2024-01-28T00:00:00.000Z",formattedDate:"January 28, 2024",tags:[{label:"rust",permalink:"/blog/tags/rust"},{label:"memory safety",permalink:"/blog/tags/memory-safety"},{label:"cult",permalink:"/blog/tags/cult"},{label:"hype",permalink:"/blog/tags/hype"}],readingTime:15.395,hasTruncateMarker:!0,authors:[{name:"Matej Focko",email:"me+blog@mfocko.xyz",title:"a.k.a. passionate language hater",url:"https://gitlab.com/mfocko",imageURL:"https://github.com/mfocko.png",key:"mf"}],frontMatter:{title:"Mixed feelings on Rust",description:"Discussing my mixed feelings about the Rust language.\n",date:"2024-01-28T00:00:00.000Z",authors:[{key:"mf",title:"a.k.a. passionate language hater"}],tags:["rust","memory safety","cult","hype"],hide_table_of_contents:!1},unlisted:!1,prevItem:{title:"LTS distributions",permalink:"/blog/2024/02/07/lts-distros"},nextItem:{title:"How can Copr help with broken dependencies",permalink:"/blog/2023/08/02/copr"}},l={authorsImageUrls:[void 0]},h=[{value:"Memory safety",id:"memory-safety",level:2},{value:"Compiler",id:"compiler",level:3},{value:"Enforcing the safety",id:"enforcing-the-safety",level:3},{value:"Consequences",id:"consequences",level:3},{value:"Development &amp; design",id:"development--design",level:2},{value:"Fast development cycle",id:"fast-development-cycle",level:3},{value:"RFCs",id:"rfcs",level:3},{value:"Community and hype train",id:"community-and-hype-train",level:2},{value:"Rust in Linux",id:"rust-in-linux",level:3},{value:"Packaging",id:"packaging",level:2},{value:"Likes",id:"likes",level:2},{value:"Workflow and toolchain",id:"workflow-and-toolchain",level:3},{value:"Standard library",id:"standard-library",level:3},{value:"<code>unsafe</code>",id:"unsafe",level:3},{value:"Traits",id:"traits",level:3},{value:"Influence of functional paradigm",id:"influence-of-functional-paradigm",level:3},{value:"Macros",id:"macros",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Rust has become a rather popular language these days. I've managed to get my\nhands dirty with it during ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.a,{href:"https://adventofcode.com",children:"Advent of Code"})})," \u201822 and partially \u201823. I've also\nused it for few rounds of ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.a,{href:"https://codeforces.com",children:"Codeforces"})})," and I have to try very hard to maintain\nsome variety of languages for LeetCode challenges along with the Rust. I'll\ndisclaim up front that I won't be only positive, since this post is a result of\nmultiple discussions about Rust and I stand by\n",(0,s.jsx)(n.em,{children:"\u201cAll that glitters is not gold\u201d"}),", so if you can't stand your favorite language\nbeing criticized in any way, don't even proceed. ","\ud83d\ude09"]}),"\n",(0,s.jsx)(n.h2,{id:"memory-safety",children:"Memory safety"}),"\n",(0,s.jsx)(n.p,{children:"I'll start by kicking the biggest benefit of the language, the memory safety.\nLet's be honest here, majority of the checks rely on the static analysis, cause\nyou can't do anything else during the compile-time, right? Therefore we can\nbasically say that we are relying on the compiler to \u201csolve\u201d all of our issues."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["I'm not doubting the fact that compiler can prevent ",(0,s.jsx)(n.strong,{children:"a lot"})," of the memory\nerrors, I'm just saying it's not realistic to cover ",(0,s.jsx)(n.strong,{children:"everything"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"compiler",children:"Compiler"}),"\n",(0,s.jsxs)(n.p,{children:["I guess we can safely",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2-e21849",id:"user-content-fnref-2-e21849","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," agree on the fact that we 100% rely on the compiler to\n",(0,s.jsx)(n.em,{children:"have our back"}),". Is the compiler bug-free? I doubt it. This is not meant in an\noffensive way to the Rust compiler developers, but we need to be realistic here.\nIt's a compiler, even older and larger projects like ",(0,s.jsx)(n.em,{children:"gcc"})," or ",(0,s.jsx)(n.em,{children:"llvm"})," can't avoid\nbugs to appear."]}),"\n",(0,s.jsxs)(n.p,{children:["When I was trying out Rust for some of the LeetCode challenges I've stumbled\nupon the following warning:\n",(0,s.jsx)(n.img,{src:"https://i.imgur.com/NfPLF6o.png",alt:"Example of a compiler bug"})]}),"\n",(0,s.jsxs)(n.admonition,{type:"danger",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{children:(0,s.jsx)(n.a,{href:"https://github.com/rust-lang/rust/issues/59159",children:"Issue"})}),(0,s.jsx)(n.p,{children:"The issue here comes from the fact that we have 2 simultaneous references to the\nsame memory (one is mutable and one immutable). If you cannot think of any way\nthis can break, I'll give you a rather simple example from C++ where this could\ncause an issue."}),(0,s.jsx)(n.p,{children:"Imagine a function that has some complex object and also calls a coroutine which\nutilizes read-only reference to that object. When the coroutine suspends, the\ncaller can modify the object. This can break the integrity of data read by the\ncoroutine."}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Yes, this ",(0,s.jsx)(n.strong,{children:"can"})," cause a memory error."]}),"\n",(0,s.jsxs)(n.li,{children:["Yes, this ",(0,s.jsx)(n.strong,{children:"hasn't"})," been handled until someone noticed it."]}),"\n"]}),(0,s.jsx)(n.p,{children:"Fixing this bug is not backwards compatible, cause you're covering a case that\nhasn't been covered before."})]}),"\n",(0,s.jsx)(n.h3,{id:"enforcing-the-safety",children:"Enforcing the safety"}),"\n",(0,s.jsxs)(n.p,{children:["One of the ways Rust enforces the safety is by restricting what you can do, like\nthe example above. Aforementioned issue ",(0,s.jsx)(n.em,{children:"can"})," happen, but ",(0,s.jsx)(n.strong,{children:"doesn't have to"}),".\nRule of the thumb in the Rust compiler is to ",(0,s.jsx)(n.em,{children:"\u201cblock\u201d"})," anything that can be an\nissue, static analysis can't do much more, it cannot decide whether it's safe to\ndo it or not."]}),"\n",(0,s.jsxs)(n.p,{children:["Satisfying the Rust compiler is sometimes a brutal pain in the ass, because you\ncannot do things like you're used to, you need to work around them ",(0,s.jsx)(n.em,{children:"somehow"}),"."]}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["Key difference between Rust and C or C++ lies in the fact that Rust chooses to\n",(0,s.jsx)(n.em,{children:"ban"})," all \u201cpotentially offensive\u201d actions, C and C++ ",(0,s.jsx)(n.em,{children:"relies"})," on ",(0,s.jsx)(n.strong,{children:"you"})," to be\nsure it's safe to do."]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://i.imgur.com/0vbkYPp.png",alt:"C++ v. Rust"})})]}),"\n",(0,s.jsx)(n.h3,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsx)(n.p,{children:"Where are we heading with this approach of \u201cif it compiles, it runs\u201d though?\nIn this aspect I have a rather similar opinion as with regards to the ChatGPT\nand its derivatives."}),"\n",(0,s.jsxs)(n.p,{children:["If you teach people to 100% depend on the compiler, they will do it, cause it's\n",(0,s.jsx)(n.em,{children:"easy"}),". All you need to do is make the compiler ",(0,s.jsx)(n.em,{children:"shut up"}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-3-e21849",id:"user-content-fnref-3-e21849","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),". Giving up the\n",(0,s.jsx)(n.em,{children:"intellectual masturbation"})," about the memory safety will make you lose your edge\nover the time. When we get to the point of everyone being in the mindset\nmentioned above, who's going to maintain the compiler? This is the place where\nyou ",(0,s.jsx)(n.strong,{children:"need to"})," think about the memory safety and furthermore in a much more\ngeneral way than in your own projects, because it is the thing that everyone\n",(0,s.jsx)(n.em,{children:"blindly believes in"})," in the end."]}),"\n",(0,s.jsxs)(n.p,{children:["I'm not saying that everyone should give up Rust and think about their memory\nmanagement and potential memory issues. I'm just saying that going the easy way\nwill make people ",(0,s.jsx)(n.em,{children:"dull"})," and they should think about it anyways, that's how the\nissue above has been discovered. If everyone walked past and didn't think about\nit, no one would discover this issue till it bit them hard."]}),"\n",(0,s.jsxs)(n.admonition,{title:"Standard library",type:"tip",children:[(0,s.jsxs)(n.p,{children:["Even the standard library is littered with ",(0,s.jsx)(n.code,{children:"unsafe"})," blocks that are prefixed\nwith comments in style:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rs",children:"// SAFETY: \u2026\n"})}),(0,s.jsxs)(n.p,{children:["The fact that the ",(0,s.jsx)(n.em,{children:"casual"})," Rust dev doesn't have to think much about safety,\ncause the compiler has their back, doesn't mean that the Rust compiler dev\ndoesn't either."]}),(0,s.jsxs)(n.p,{children:["I gotta admit that I adopted this concept in other languages (even in Python),\ncause you can encounter situations where it doesn't have to be clear ",(0,s.jsx)(n.em,{children:"why"})," you\ncan do ",(0,s.jsx)(n.em,{children:"what"})," you're doing."]})]}),"\n",(0,s.jsx)(n.h2,{id:"development--design",children:"Development & design"}),"\n",(0,s.jsx)(n.p,{children:"Development of Rust is\u2026 very fast. One positive is that they're trying to be as\nbackward compatible as possible at least by verifying against all the published\ncrates in the process. Of course, you cannot be backward compatible about fixing\nthe bugs that have been found, but such is life."}),"\n",(0,s.jsx)(n.h3,{id:"fast-development-cycle",children:"Fast development cycle"}),"\n",(0,s.jsx)(n.p,{children:"One of the negatives of the fast development cycle is the fact that they're\nusing the latest features already in the next release of the Rust. Yes, it is\nsomething that you can use for verifying and testing your own changes, but at\nthe same time it places a requirement of the latest release to compile the next\none."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["If you check ",(0,s.jsx)(n.code,{children:"gcc"})," for example, they have a requirement of minimal version of\ncompiler that you need for the build. Though gcc's requirement is not so ",(0,s.jsx)(n.em,{children:"needy"}),"\nas the Rust one."]})}),"\n",(0,s.jsx)(n.p,{children:"One of the other negatives is the introduction of bugs. If you're pushing\nchanges, somewhat mindlessly, at such a fast pace, it is inevitable to introduce\na bunch bugs in the process. Checking the GitHub issue tracker with"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"is:issue is:open label:C-bug label:T-compiler\n"})}),"\n",(0,s.jsxs)(n.p,{children:["yields ",(0,s.jsx)(n.strong,{children:"2,224"})," open issues at the time of writing this post."]}),"\n",(0,s.jsx)(n.h3,{id:"rfcs",children:"RFCs"}),"\n",(0,s.jsxs)(n.p,{children:["You can find ",(0,s.jsx)(n.strong,{children:"a lot"})," of RFCs for the Rust. Some of them are more questionable\nthan the others. Fun thing is that a lot of them make it to the nightly builds,\nso they can be tested and polished off. Even the questionable ones\u2026 I'll leave\nfew examples for a better understanding."]}),"\n",(0,s.jsxs)(n.p,{children:["One of such features is the ",(0,s.jsx)(n.code,{children:"do yeet"})," expression:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#![feature(yeet_expr)]\n\nfn foo() -> Result<String, i32> {\n    do yeet 4;\n}\nassert_eq!(foo(), Err(4));\n\nfn bar() -> Option<String> {\n    do yeet;\n}\nassert_eq!(bar(), None);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It allows you to \u201cyeet\u201d the errors out of the functions that return ",(0,s.jsx)(n.code,{children:"Result"})," or\n",(0,s.jsx)(n.code,{children:"Option"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/rust-lang/rfcs/pull/3503",children:"One"})," of the more recent ones is\nthe ability to include Cargo manifests into the sources, so you can do something\nlike:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#!/usr/bin/env cargo\n---\n[dependencies]\nclap = { version = "4.2", features = ["derive"] }\n---\n\nuse clap::Parser;\n\n#[derive(Parser, Debug)]\n#[clap(version)]\nstruct Args {\n    #[clap(short, long, help = "Path to config")]\n    config: Option<std::path::PathBuf>,\n}\n\nfn main() {\n    let args = Args::parse();\n    println!("{:?}", args);\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"I would say you can get almost anything into the language\u2026"}),"\n",(0,s.jsx)(n.h2,{id:"community-and-hype-train",children:"Community and hype train"}),"\n",(0,s.jsxs)(n.p,{children:["Rust community is a rather unique thing. A lot of people will hate me for this,\nbut I can't help, but to compare them to ",(0,s.jsx)(n.em,{children:"militant vegans"}),". I'll go through some\nof the things related to it, so I can support my opinion at least."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Rust is the best language."})," It is not. There is no best language, each has its\nown positives and negatives, you need to choose the language that's ",(0,s.jsx)(n.strong,{children:"the most"}),"\n",(0,s.jsx)(n.strong,{children:"suitable for your use case"}),". There are areas where Rust excels, though I have\nto admit it's very close to being a universal hammer regardless of how suitable\nit is. There is a very steep learning curve to it, beginnings in Rust are very\npainful."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Rewrite everything in Rust."})," Just no. There are multiple feedbacks on doing\nrewrites, it is very common to fix ",(0,s.jsx)(n.em,{children:"N"})," bugs with a rewrite while introducing\n",(0,s.jsx)(n.em,{children:"N + 1"})," other bugs in the process. It doesn't solve anything unless there are\nsome strong reasons to go with it. Majority of such suggested rewrites don't\nhave those reasons though."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Language \u2039x\u203a is bad, though in Rust\u2026"})," Cherry-picking one specific pain point of\none language and reflecting how it is better in other language can go both ways.\nFor example it is rather easy to pick the limitations imposed by Rust compiler\nand show how it's possible in other languages ","\ud83e\udd37\u200d\u2642\ufe0f"]}),"\n",(0,s.jsx)(n.p,{children:"I don't mind any of those opinions, you're free to have them, as long as you\ndon't rub them in my face which is not the usual case\u2026 This experience makes it\njust worse for me, part of this post may be also influenced by this fact."}),"\n",(0,s.jsx)(n.h3,{id:"rust-in-linux",children:"Rust in Linux"}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"As someone who has seen the way Linux kernel is built in the RHEL ecosystem, how\ncomplex the whole thing is and how much resources you need to proceed, I have\nvery strong opinions on this topic."})}),"\n",(0,s.jsx)(n.p,{children:"It took years of work to even \u201cincorporate\u201d Rust into the Linux codebase, just\nto get the \u201cHello World!\u201d. I don't have anything against the idea of writing\ndrivers in the Rust, I bet it can catch a lot of common mistakes, but still\nintroducing Rust to the kernel is another step to enlarge the monster."}),"\n",(0,s.jsxs)(n.p,{children:["I have to admit though that the ",(0,s.jsx)(n.em,{children:"Apple GPU"})," driver for Linux written in Rust is\nquite impressive. Apart from that there are not so many benefits, yet\u2026"]}),"\n",(0,s.jsx)(n.h2,{id:"packaging",children:"Packaging"}),"\n",(0,s.jsx)(n.p,{children:"I'll divide the packaging into the packaging of the language itself and the\nprograms written in Rust."}),"\n",(0,s.jsxs)(n.p,{children:["Let's start with the ",(0,s.jsx)(n.code,{children:"cargo"})," itself though. Package managers of the languages\nusually get a lot of hate (you can take ",(0,s.jsx)(n.code,{children:"npm"})," or ",(0,s.jsx)(n.code,{children:"pip"})," as examples",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1-e21849",id:"user-content-fnref-1-e21849","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),"). If\nyou've ever tried out Rust, I bet you already know where I'm going with this.\nYes, I mean the compilation times, or even Cargo downloading ",(0,s.jsx)(n.em,{children:"whole"})," index of\ncrates just so you can update that one dependency (and 3 millions of indirect\ndeps). When I was doing AoC \u201822 in Rust, I've set up ",(0,s.jsx)(n.code,{children:"sccache"})," right away on the\nfirst day."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's move to the packaging of the Rust itself, it's tedious. Rust has a very\nfast development cycle and doesn't even try to make the builds backward\ncompatible. If there is a new release of Rust, there is a very high chance that\nyou cannot build that release with anything other than ",(0,s.jsx)(n.strong,{children:"the latest"})," Rust\nrelease. If you have ever touched the packaging, you know that this is something\nthat can cause a lot of problems, cause you need the second-to-latest version to\ncompile the latest version, don't forget that this applies inductively\u2026 People\nrunning ",(0,s.jsx)(n.em,{children:"Gentoo"})," could tell you a lot about this."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Compiling the compilers takes usually more time than compiling the kernel\nitself\u2026"})}),"\n",(0,s.jsxs)(n.p,{children:["I cannot speak about packaging of Rust programs in other than RHEL-based\ndistros, though I can speak about RHEL ecosystem. Fedora packaging guidelines\nspecify that you need to build each and every dependency of the program\nseparately. I wanted to try out ",(0,s.jsx)(n.em,{children:"AlmaLinux"})," and install Alacritty there and I\nfailed miserably. The solution that worked, consisted of ignoring the packaging\nguidelines, running ",(0,s.jsx)(n.code,{children:"cargo build"})," and consuming the binaries afterwards.\nDependencies of the Rust programs are of a similar nature as JS dependencies."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["I'm tipping my fedora",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2-e21849",id:"user-content-fnref-2-e21849-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," in the general direction of the maintainers of Rust\npackages in RHEL ecosystem. I wouldn't be able to do this without losing my\nsanity."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"likes",children:"Likes"}),"\n",(0,s.jsxs)(n.p,{children:["If you've come all the way here and you're a Rustacean, I believe I've managed\nto get your blood boiling, so it's time to finish this off by stuff I like about\nRust. I doubt I will be able to cover everything, but I can try at least. You\nhave to admit it's much easier to remember the bad stuff as opposed to the good.\n","\ud83d\ude09"]}),"\n",(0,s.jsx)(n.h3,{id:"workflow-and-toolchain",children:"Workflow and toolchain"}),"\n",(0,s.jsxs)(n.p,{children:["I prefered using Rust for the ",(0,s.jsx)(n.em,{children:"Advent of Code"})," and ",(0,s.jsx)(n.em,{children:"Codeforces"})," as it provides\na rather easy way to test the solutions before running them with the challenge\ninput (or test runner). I can give an example from the ",(0,s.jsx)(n.em,{children:"Advent of Code"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use aoc_2023::*;\n\ntype Output1 = i32;\ntype Output2 = Output1;\n\nstruct DayXX {}\nimpl Solution<Output1, Output2> for DayXX {\n    fn new<P: AsRef<Path>>(pathname: P) -> Self {\n        let lines: Vec<String> = file_to_lines(pathname);\n\n        todo!()\n    }\n\n    fn part_1(&mut self) -> Output1 {\n        todo!()\n    }\n\n    fn part_2(&mut self) -> Output2 {\n        todo!()\n    }\n}\n\nfn main() -> Result<()> {\n    DayXX::main()\n}\n\ntest_sample!(day_XX, DayXX, 42, 69);\n"})}),"\n",(0,s.jsx)(n.p,{children:"This was the skeleton I've used and the macro at the end is my own creation that\nexpands to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[cfg(test)]\nmod day_XX {\n    use super::*;\n\n    #[test]\n    fn part_1() {\n        let path = DayXX::get_sample(1);\n        let mut day = DayXX::new(path);\n        assert_eq!(day.part_1(), 42);\n    }\n\n    #[test]\n    fn part_2() {\n        let path = DayXX::get_sample(2);\n        let mut day = DayXX::new(path);\n        assert_eq!(day.part_2(), 69);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When you're solving the problem, all you need to do is switch between\n",(0,s.jsx)(n.code,{children:"cargo test"})," and ",(0,s.jsx)(n.code,{children:"cargo run"})," to check the answer to either sample or the\nchallenge input itself."]}),"\n",(0,s.jsxs)(n.p,{children:["Introduce ",(0,s.jsx)(n.a,{href:"https://dystroy.org/bacon/",children:"bacon"})," and it gets even better. Bacon is a CLI tool that wraps around\nthe ",(0,s.jsx)(n.code,{children:"cargo"})," and allows you to check, run, lint or run tests on each file save.\nIt's a very pleasant thing for a so-called ",(0,s.jsx)(n.em,{children:"compiler-assisted"})," development."]}),"\n",(0,s.jsxs)(n.p,{children:["Speaking of linting from within the bacon, you cannot leave out the ",(0,s.jsx)(n.a,{href:"https://github.com/rust-lang/rust-clippy",children:"clippy"}),".\nNot only it can whip your ass because of errors, but it can also produce a lot\nof helpful suggestions, for example passing slices by borrow instead of\nborrowing the ",(0,s.jsx)(n.code,{children:"Vec"})," itself when you don't need it."]}),"\n",(0,s.jsx)(n.h3,{id:"standard-library",children:"Standard library"}),"\n",(0,s.jsxs)(n.p,{children:["There's ",(0,s.jsx)(n.strong,{children:"a lot"})," included in the standard library. It almost feels like you\nhave all you need",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-4-e21849",id:"user-content-fnref-4-e21849","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})}),". I like placeholders (like ",(0,s.jsx)(n.code,{children:"todo!()"}),", ",(0,s.jsx)(n.code,{children:"unreachable!()"}),",\n",(0,s.jsx)(n.code,{children:"unimplemented!()"}),") to the extent of\n",(0,s.jsx)(n.a,{href:"/cpp/exceptions-and-raii/placeholders",children:"implementing"})," them as exceptions in C++."]}),"\n",(0,s.jsx)(n.p,{children:"You can find almost anything. Though you can also hit some very weird issues\nwith some of the nuances of the type system."}),"\n",(0,s.jsx)(n.h3,{id:"unsafe",children:(0,s.jsx)(n.code,{children:"unsafe"})}),"\n",(0,s.jsxs)(n.p,{children:["This might be something that people like to avoid as much as possible. However I\nthink that forming a habit of commenting posibly unsafe operations in ",(0,s.jsx)(n.strong,{children:"any"}),"\nlanguage is a good habit, as I've mentioned above. You should be able to argue\nwhy you can do something safely, even if the compiler is not kicking your ass\nbecause of it."]}),"\n",(0,s.jsx)(n.p,{children:"Excerpt of such comment from work:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-py",children:"# SAFETY: Taking first package instead of specific package should be\n# safe, since we have put a requirement on \xbbone\xab \u2039upstream_project_url\u203a\n# per Packit config, i.e. even if we're dealing with a monorepo, there\n# is only \xbbone\xab upstream. If there is one upstream, there is only one\n# set of GPG keys that can be allowed.\nreturn self.downstream_config.packages[\n    self.downstream_config._first_package\n].allowed_gpg_keys\n"})}),"\n",(0,s.jsx)(n.h3,{id:"traits",children:"Traits"}),"\n",(0,s.jsxs)(n.p,{children:["One of the other things I like are the traits. They are more restrictive than\ntemplates or concepts in C++, but they're doing their job pretty good. If you\nare building library and require multiple traits to be satisfied it means a lot\nof copy-paste, but that's soon to be fixed by the ",(0,s.jsx)(n.a,{href:"https://github.com/rust-lang/rfcs/blob/master/text/1733-trait-alias.md",children:"trait aliases"}),"."]}),"\n",(0,s.jsxs)(n.admonition,{title:"Comparing to other languages",type:"tip",children:[(0,s.jsxs)(n.p,{children:["On Wikipedia I've seen trait being defined as a more restrictive type class as\nyou may know it from the Haskell for example. C++ isn't behind either with its\n",(0,s.jsx)(n.em,{children:"constraints and concepts"}),". I would say that we can order them in the following\norder based on the complexity they can express:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Rust's trait < Haskell's type class < C++'s concept\n"})})]}),"\n",(0,s.jsxs)(n.p,{children:["You can also hit some issues, like me when trying to support conversions between\nunderlying numeric types of a 2D vectors or support for using an operator from\nboth sides (I couldn't get ",(0,s.jsx)(n.code,{children:"c * u"})," to work in the same way as ",(0,s.jsx)(n.code,{children:"u * c"})," because\nthe first one requires you to implement the trait of a built-in type)."]}),"\n",(0,s.jsxs)(n.admonition,{title:"Implementation",type:"warning",children:[(0,s.jsx)(n.p,{children:"Implementing traits lies in"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"impl SomeTrait for SomeStruct {\n    // implementation goes here\n}\n"})}),(0,s.jsxs)(n.p,{children:["One of the things I ",(0,s.jsx)(n.strong,{children:"would love to"})," see is being able to define the helper\nfunctions within the same block. As of now, the only things allowed are the ones\nthat are required by the trait, which in the end results in a randomly lying\nfunctions around (or in a implementation of the structure itself). I don't like\nthis mess at all\u2026"]})]}),"\n",(0,s.jsx)(n.h3,{id:"influence-of-functional-paradigm",children:"Influence of functional paradigm"}),"\n",(0,s.jsxs)(n.p,{children:["You can see a big influence of the functional paradigm. Not only in iterators,\nbut also in the other parts of the language. For example I prefer ",(0,s.jsx)(n.code,{children:"Option<T>"})," or\n",(0,s.jsx)(n.code,{children:"Result<T, E>"})," to ",(0,s.jsx)(n.code,{children:"null"}),"s and exceptions. Pattern matching together with\ncompiler both enforces handling of the errors and rather user-friendly way of\ndoing it."]}),"\n",(0,s.jsxs)(n.p,{children:["Not to mention ",(0,s.jsx)(n.code,{children:".and_then()"})," and such. However spending most of the time with\nthe AoC you get pretty annoyed of the repetitive ",(0,s.jsx)(n.code,{children:".unwrap()"})," during parsing,\nsince you are guaranteed correct input."]}),"\n",(0,s.jsx)(n.h3,{id:"macros",children:"Macros"}),"\n",(0,s.jsx)(n.p,{children:"Macros are a very strong pro of the Rust. And no, we're not going to talk about\nthe procedural macros\u2026"}),"\n",(0,s.jsx)(n.p,{children:"As I've shown above I've managed to \u201ctame\u201d a lot of copy-paste in the tests for\nthe AoC by utilizing a macro that generated a very basic template for the tests."}),"\n",(0,s.jsxs)(n.p,{children:["As I have mentioned the traits above, I cannot forget to give props to ",(0,s.jsx)(n.code,{children:"derive"}),"\nmacro that allows you to \u201cdeduce\u201d the default implementation. It is very helpful\nfor a tedious tasks like implementing ",(0,s.jsx)(n.code,{children:"Debug"})," (for printing out the structures)\nor comparisons, though with the comparisons you need to be careful about the\ndefault implementation, it has already bitten me once or twice."]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.p,{children:["Overall there are many things about the Rust I like and would love to see them\nimplemented in other languages. However there are also many things I don't like.\nNothing is ",(0,s.jsx)(n.strong,{children:"exclusively"})," black and white."]}),"\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-2-e21849",children:["\n",(0,s.jsxs)(n.p,{children:["pun intended ",(0,s.jsx)(n.a,{href:"#user-content-fnref-2-e21849","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})," ",(0,s.jsxs)(n.a,{href:"#user-content-fnref-2-e21849-2","data-footnote-backref":"","aria-label":"Back to reference 1-2",className:"data-footnote-backref",children:["\u21a9",(0,s.jsx)(n.sup,{children:"2"})]})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-3-e21849",children:["\n",(0,s.jsxs)(n.p,{children:["It's not that easy with the Rust compiler, but OK\u2026 ",(0,s.jsx)(n.a,{href:"#user-content-fnref-3-e21849","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1-e21849",children:["\n",(0,s.jsxs)(n.p,{children:["not to even mention multiple different packaging standards Python has, which\nis borderline ",(0,s.jsx)(n.a,{href:"https://xkcd.com/927/",children:"https://xkcd.com/927/"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1-e21849","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-4-e21849",children:["\n",(0,s.jsxs)(n.p,{children:["unlike Python where there's whole universe in the language itself, yet there\nare essential things not present\u2026 ",(0,s.jsx)(n.a,{href:"#user-content-fnref-4-e21849","data-footnote-backref":"","aria-label":"Back to reference 4",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var s=t(67294);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);