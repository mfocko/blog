"use strict";(self.webpackChunkfi=self.webpackChunkfi||[]).push([[4818],{1217:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var o=t(83591),i=t(74848),r=t(28453);const a={title:"3rd week of Advent of Code '22 in Rust",description:"Surviving third week in Rust.",date:"2023-07-06T21:00",slug:"aoc-2022/3rd-week",authors:"mf",tags:["advent-of-code","advent-of-code-2022","rust"],hide_table_of_contents:!1},s=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Day 15: Beacon Exclusion Zone",id:"day-15-beacon-exclusion-zone",level:2},{value:"Solution",id:"solution",level:3},{value:"Day 16: Proboscidea Volcanium",id:"day-16-proboscidea-volcanium",level:2},{value:"Solution",id:"solution-1",level:3},{value:"Indexing in graph",id:"indexing-in-graph",level:4},{value:"Cartesian product",id:"cartesian-product",level:4},{value:"\u201cImplementing\u201d an iterator",id:"implementing-an-iterator",level:4},{value:"Day 17: Pyroclastic Flow",id:"day-17-pyroclastic-flow",level:2},{value:"Solution",id:"solution-2",level:3},{value:"Collision detection",id:"collision-detection",level:4},{value:"Infinite iterator",id:"infinite-iterator",level:4},{value:"Day 18: Boiling Boulders",id:"day-18-boiling-boulders",level:2},{value:"Solution",id:"solution-3",level:3},{value:"Day 19: Not Enough Minerals",id:"day-19-not-enough-minerals",level:2},{value:"Solution",id:"solution-4",level:3},{value:"Day 20: Grove Positioning System",id:"day-20-grove-positioning-system",level:2},{value:"Solution",id:"solution-5",level:3},{value:"<code>.borrow_mut()</code>",id:"borrow_mut",level:4},{value:"<code>.borrow_mut()</code> on <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>",id:"borrow_mut-on-rcrefcellt",level:5},{value:"<code>BorrowMut</code> trait",id:"borrowmut-trait",level:5},{value:"Conflict",id:"conflict",level:5},{value:"Day 21: Monkey Math",id:"day-21-monkey-math",level:2},{value:"Solution",id:"solution-6",level:3},{value:"<code>Default</code> trait",id:"default-trait",level:4},{value:"Abusing negation",id:"abusing-negation",level:4}];function c(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Let's go through the third week of ",(0,i.jsx)(n.a,{href:"https://adventofcode.com",children:(0,i.jsx)(n.em,{children:"Advent of Code"})})," in Rust."]}),"\n",(0,i.jsx)(n.h2,{id:"day-15-beacon-exclusion-zone",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2022/day/15",children:"Day 15: Beacon Exclusion Zone"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Triangulating a distress beacon based on the information from the sensors."})}),"\n",(0,i.jsx)(n.h3,{id:"solution",children:"Solution"}),"\n",(0,i.jsx)(n.p,{children:"Relatively easy thing to implement, no major Rust issues hit."}),"\n",(0,i.jsx)(n.h2,{id:"day-16-proboscidea-volcanium",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2022/day/16",children:"Day 16: Proboscidea Volcanium"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Finding a max flow in a graph given some time constraints."})}),"\n",(0,i.jsx)(n.h3,{id:"solution-1",children:"Solution"}),"\n",(0,i.jsx)(n.p,{children:"I have used some interesting things to implement this and make it easier for me."}),"\n",(0,i.jsx)(n.h4,{id:"indexing-in-graph",children:"Indexing in graph"}),"\n",(0,i.jsx)(n.p,{children:"I have come across a situation where I needed to keep more information regarding\nthe graph\u2026 In that case you can, of course, create a structure and keep it in,\nbut once you have multiple members in the structure it gets harder to work with\nsince you need to address the fields in the structure. When you work with graph,\nyou frequently need to access the vertices and in this case it felt a lot easier\nto implement the indexing in a graph, rather than explicitly access the\nunderlying data structure."}),"\n",(0,i.jsx)(n.p,{children:"Here you can see a rather short snippet from the solution that allows you to\n\u201cindex\u201d the graph:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"impl Index<&str> for Graph {\n    type Output = Vertex;\n\n    fn index(&self, index: &str) -> &Self::Output {\n        &self.g[index]\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"cartesian-product",children:"Cartesian product"}),"\n",(0,i.jsxs)(n.p,{children:["During the implementation I had to utilize Floyd-Warshall algorithm for finding\nthe shortest path between pairs of vertices and utilized the ",(0,i.jsx)(n.code,{children:"iproduct!"})," macro\nfrom the ",(0,i.jsx)(n.a,{href:"https://crates.io/crates/itertools",children:(0,i.jsx)(n.code,{children:"itertools"})}),". It is a very useful higher-order function that allows\nyou to keep the nesting of the loops at a minimum level while still maintaining\nthe same functionality."]}),"\n",(0,i.jsx)(n.h4,{id:"implementing-an-iterator",children:"\u201cImplementing\u201d an iterator"}),"\n",(0,i.jsx)(n.p,{children:"For the second part, you get to split the work between 2 actors. That way you\ncan achieve higher efficiency of the whole process that you're planning, but it\nalso makes it harder to evaluate algorithmically, since you need to check the\ndifferent ways the work can be split."}),"\n",(0,i.jsxs)(n.p,{children:["Being affected by ",(0,i.jsx)(n.em,{children:"functional programming brain damage"}),"\u2122\ufe0f",", I have chosen to\ndo this part by function that returns an iterator over the possible ways:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn pairings(\n    valves: &BTreeSet<String>,\n) -> impl Iterator<Item = (BTreeSet<String>, BTreeSet<String>)> + '_ {\n    let mapping = valves.iter().collect_vec();\n\n    let max_mask = 1 << (valves.len() - 1);\n\n    (0..max_mask).map(move |mask| {\n        let mut elephant = BTreeSet::new();\n        let mut human = BTreeSet::new();\n\n        for (i, &v) in mapping.iter().enumerate() {\n            if (mask & (1 << i)) == 0 {\n                human.insert(v.clone());\n            } else {\n                elephant.insert(v.clone());\n            }\n        }\n\n        (human, elephant)\n    })\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"day-17-pyroclastic-flow",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2022/day/17",children:"Day 17: Pyroclastic Flow"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Simulating an autonomous Tetris where pieces get affected by a series of jets of\nhot gas."})}),"\n",(0,i.jsx)(n.h3,{id:"solution-2",children:"Solution"}),"\n",(0,i.jsxs)(n.p,{children:["Similarly to the previous day I have created some iterators ","\ud83d\ude04"]}),"\n",(0,i.jsx)(n.h4,{id:"collision-detection",children:"Collision detection"}),"\n",(0,i.jsx)(n.p,{children:"Once you need to check for collisions it is very helpful to be able to just\niterate through the positions that can actually collide with the wall or other\npiece."}),"\n",(0,i.jsx)(n.p,{children:"To get the desired behaviour, you can just compose few smaller functions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn occupied(shape: &[Vec<char>]) -> impl Iterator<Item = Position> + '_ {\n    shape.iter().enumerate().flat_map(|(y, row)| {\n        row.iter().enumerate().filter_map(move |(x, c)| {\n            if c == &'#' {\n                Some(Vector2D::new(x as isize, y as isize))\n            } else {\n                None\n            }\n        })\n    })\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the end, we get relative positions which we can adjust later when given the\nspecific positions from iterator. You can see some interesting parts in this:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".enumerate()"})," allows us to get both the indices (coordinates) and the line\nor, later on, the character itself,"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".flat_map()"})," flattens the iterator, i.e. when we return another iterator,\nthey just get chained instead of iterating over iterators (which sounds pretty\ndisturbing, doesn't it?),"]}),"\n",(0,i.jsxs)(n.li,{children:["and finally ",(0,i.jsx)(n.code,{children:".filter_map()"})," which is pretty similar to the \u201cbasic\u201d ",(0,i.jsx)(n.code,{children:".map()"}),"\nwith a one, key, difference that it expects the items of an iterator to be\nmapped to an ",(0,i.jsx)(n.code,{children:"Option<T>"})," from which it ignores nothing (as in ",(0,i.jsx)(n.code,{children:"None"})," ","\ud83d\ude09",")\nand also unwraps the values from ",(0,i.jsx)(n.code,{children:"Some(\u2026)"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"infinite-iterator",children:"Infinite iterator"}),"\n",(0,i.jsx)(n.p,{children:"In the solution we cycle through both Tetris-like shapes that fall down and the\njets that move our pieces around. Initially I have implemented my own infinite\niterator that just yields the indices. It is a very simple, yet powerful, piece\nof code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"struct InfiniteIndex {\n    size: usize,\n    i: usize,\n}\n\nimpl InfiniteIndex {\n    fn new(size: usize) -> InfiniteIndex {\n        InfiniteIndex { size, i: size - 1 }\n    }\n}\n\nimpl Iterator for InfiniteIndex {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.i = (self.i + 1) % self.size;\n        Some(self.i)\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["However when I'm looking at the code now, it doesn't really make much sense\u2026\nGuess what, we can use a built-in function that is implemented on iterators for\nthat! The function is called ",(0,i.jsx)(n.code,{children:".cycle()"})]}),"\n",(0,i.jsx)(n.p,{children:"On the other hand, I am not going to switch to that function, since it would\nintroduce an another myriad of issues caused by the fact that I create iterators\nright away in the constructor of my structure and the iterators would borrow\nboth the jets and shapes which would introduce a lifetime dependency into the\nstructure."}),"\n",(0,i.jsx)(n.h2,{id:"day-18-boiling-boulders",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2022/day/18",children:"Day 18: Boiling Boulders"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Let's compute a surface area of some obsidian approximated via coordinates of\ncubes."})}),"\n",(0,i.jsx)(n.h3,{id:"solution-3",children:"Solution"}),"\n",(0,i.jsx)(n.p,{children:"This day is kinda interesting, because it shows how easily you can complicate the\nproblem and also how much can you screw yourself over with the optimization and\n\u201csmart\u201d approach."}),"\n",(0,i.jsxs)(n.p,{children:["For the first part you need to find the surface area of an obsidian that is\napproximated by cubes. Now, that is a very easy thing to do, just keep the track\nof already added cubes, and check if the newly added cube touches any face of any\nother cube. Simple, and with a ",(0,i.jsx)(n.code,{children:"BTreeSet"})," relatively efficient way to do it."]}),"\n",(0,i.jsx)(n.p,{children:"However the second part lets you on a secret that there may be some surface area\nfrom the \u201cinside\u201d too and you want to know only the one from the outside of the\nobsidian. I have seen some solutions later, but if you check your data, you might\nnotice that the bounding box of all the cubes isn't that big at all. Therefore I\nchose to pre-construct the box beforehand, fill in the cubes and then just run a\nBFS turning all the lava on the outside into the air. Now you just need to check\ncubes and count how many of their faces touch the air."}),"\n",(0,i.jsx)(n.h2,{id:"day-19-not-enough-minerals",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2022/day/19",children:"Day 19: Not Enough Minerals"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Finding out the best strategy for building robots to collect geodes."})}),"\n",(0,i.jsx)(n.h3,{id:"solution-4",children:"Solution"}),"\n",(0,i.jsxs)(n.p,{children:["Not much interesting stuff to mention apart from the suggestion to never believe\nthat the default implementation given by ",(0,i.jsx)(n.code,{children:"derive"})," macro is what you want, it\ndoesn't have to be. ","\ud83d\ude04"]}),"\n",(0,i.jsx)(n.h2,{id:"day-20-grove-positioning-system",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2022/day/20",children:"Day 20: Grove Positioning System"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsxs)(n.p,{children:["Shuffling around the ",(0,i.jsx)(n.em,{children:"circular linked list"})," to find the coordinates."]})}),"\n",(0,i.jsx)(n.p,{children:"Now, small rant for this day is in place. They've never mentioned that coordinates\ncan repeat and therefore the values are non-unique. This is something that did\nnot happen in the given sample, but was present in the user input. It took \xbba lot\xab\nto realize that this is the issue."}),"\n",(0,i.jsx)(n.h3,{id:"solution-5",children:"Solution"}),"\n",(0,i.jsxs)(n.p,{children:["I have tried implementing a circular linked list for this\u2026 and I have failed\nmiserably. To be fair, I still have no clue why. It was \u201cfun\u201d to play around with\nthe ",(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"}),". In the end I failed on ",(0,i.jsx)(n.em,{children:"wrong answer"}),". I have also encountered\na rather interesting issue with ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," method being used on ",(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"borrow_mut",children:(0,i.jsx)(n.code,{children:".borrow_mut()"})}),"\n",(0,i.jsx)(n.p,{children:"Consider the following snippet of the code (taken from the documentation):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use std::cell::{RefCell, RefMut};\nuse std::collections::HashMap;\nuse std::rc::Rc;\n// use std::borrow::BorrowMut;\n\nfn main() {\n    let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n    // Create a new block to limit the scope of the dynamic borrow\n    {\n        let mut map: RefMut<_> = shared_map.borrow_mut();\n        map.insert("africa", 92388);\n        map.insert("kyoto", 11837);\n        map.insert("piccadilly", 11826);\n        map.insert("marbles", 38);\n    }\n\n    // Note that if we had not let the previous borrow of the cache fall out\n    // of scope then the subsequent borrow would cause a dynamic thread panic.\n    // This is the major hazard of using `RefCell`.\n    let total: i32 = shared_map.borrow().values().sum();\n    println!("{total}");\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We allocate a hash map on the heap and then in the inner block, we borrow it as\na mutable reference, so that we can use it."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["It is a very primitive example for ",(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"})," and mutable borrow."]})}),"\n",(0,i.jsxs)(n.p,{children:["If you uncomment the 4th line with ",(0,i.jsx)(n.code,{children:"use std::borrow::BorrowMut;"}),", you cannot\ncompile the code anymore, because of"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"   Compiling playground v0.0.1 (/playground)\nerror[E0308]: mismatched types\n  --\x3e src/main.rs:10:34\n   |\n10 |         let mut map: RefMut<_> = shared_map.borrow_mut();\n   |                      ---------   ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `RefMut`, found mutable reference\n   |                      |\n   |                      expected due to this\n   |\n   = note:         expected struct `RefMut<'_, _>`\n           found mutable reference `&mut Rc<RefCell<HashMap<_, _>>>`\n\nerror[E0599]: no method named `insert` found for struct `RefMut<'_, _>` in the current scope\n  --\x3e src/main.rs:11:13\n   |\n11 |         map.insert(\"africa\", 92388);\n   |             ^^^^^^ method not found in `RefMut<'_, _>`\n\nerror[E0599]: no method named `insert` found for struct `RefMut<'_, _>` in the current scope\n  --\x3e src/main.rs:12:13\n   |\n12 |         map.insert(\"kyoto\", 11837);\n   |             ^^^^^^ method not found in `RefMut<'_, _>`\n\nerror[E0599]: no method named `insert` found for struct `RefMut<'_, _>` in the current scope\n  --\x3e src/main.rs:13:13\n   |\n13 |         map.insert(\"piccadilly\", 11826);\n   |             ^^^^^^ method not found in `RefMut<'_, _>`\n\nerror[E0599]: no method named `insert` found for struct `RefMut<'_, _>` in the current scope\n  --\x3e src/main.rs:14:13\n   |\n14 |         map.insert(\"marbles\", 38);\n   |             ^^^^^^ method not found in `RefMut<'_, _>`\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `playground` due to 5 previous errors\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It might seem ",(0,i.jsx)(n.strong,{children:"a bit"})," ridiculous. However, I got to a point where the compiler\nsuggested ",(0,i.jsx)(n.code,{children:"use std::borrow::BorrowMut;"})," and it resulted in breaking parts of the\ncode that worked previously. I think it may be a good idea to go over what is\nhappening here."]}),"\n",(0,i.jsxs)(n.h5,{id:"borrow_mut-on-rcrefcellt",children:[(0,i.jsx)(n.code,{children:".borrow_mut()"})," on ",(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"})]}),"\n",(0,i.jsxs)(n.p,{children:["Let's consider a variable ",(0,i.jsx)(n.code,{children:"x"})," of type ",(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"}),". What happens when you\ncall ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," on it? We can look at the ",(0,i.jsx)(n.code,{children:"Rc"})," type, and\u2026 hang on! There is\nneither ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," method or ",(0,i.jsx)(n.code,{children:"BorrowMut"})," trait implemented. How can we do it\nthen?"]}),"\n",(0,i.jsxs)(n.p,{children:["Let's go further and we can see that ",(0,i.jsx)(n.code,{children:"RefCell<T>"})," implements a ",(0,i.jsx)(n.code,{children:".borrow_mut()"}),"\nmethod. OK, but how can we call it on the ",(0,i.jsx)(n.code,{children:"Rc<T>"}),"? Easily! ",(0,i.jsx)(n.code,{children:"Rc<T>"})," implements\n",(0,i.jsx)(n.code,{children:"Deref<T>"})," and therefore you can call methods on ",(0,i.jsx)(n.code,{children:"Rc<T>"})," objects as if they were\n",(0,i.jsx)(n.code,{children:"T"})," objects. If we read on ",(0,i.jsxs)(n.em,{children:[(0,i.jsx)(n.code,{children:"Deref"})," coercion"]}),", we can see the following:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"T"})," implements ",(0,i.jsx)(n.code,{children:"Deref<Target = U>"}),", \u2026:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2026"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"T"})," implicitly implements all the (immutable) methods of the type ",(0,i.jsx)(n.code,{children:"U"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["What is the requirement for the ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," on ",(0,i.jsx)(n.code,{children:"RefCell<T>"}),"? Well, it needs\n",(0,i.jsx)(n.code,{children:"&self"}),", so the ",(0,i.jsx)(n.code,{children:"Deref"})," implements the ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," for the ",(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"}),"."]}),"\n",(0,i.jsxs)(n.h5,{id:"borrowmut-trait",children:[(0,i.jsx)(n.code,{children:"BorrowMut"})," trait"]}),"\n",(0,i.jsxs)(n.p,{children:["I have not been able to find a lot on this trait. My guess is that it provides a\nmethod instead of a syntactic sugar (",(0,i.jsx)(n.code,{children:"&mut x"}),") for the mutable borrow. And also\nit provides default implementations for the types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"impl BorrowMut<str> for String\n\nimpl<T> BorrowMut<T> for &mut T\nwhere\n    T: ?Sized,\n\nimpl<T> BorrowMut<T> for T\nwhere\n    T: ?Sized,\n\nimpl<T, A> BorrowMut<[T]> for Vec<T, A>\nwhere\n    A: Allocator,\n\nimpl<T, A> BorrowMut<T> for Box<T, A>\nwhere\n    A: Allocator,\n    T: ?Sized,\n\nimpl<T, const N: usize> BorrowMut<[T]> for [T; N]\n"})}),"\n",(0,i.jsx)(n.h5,{id:"conflict",children:"Conflict"}),"\n",(0,i.jsxs)(n.p,{children:["Now the question is why did it break the code\u2026 My first take was that the type\n",(0,i.jsx)(n.code,{children:"Rc<RefCell<T>>"})," has some ",(0,i.jsx)(n.em,{children:"specialized"})," implementation of the ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," and\nthe ",(0,i.jsx)(n.code,{children:"use"})," overrides it with the default, which is true ",(0,i.jsx)(n.strong,{children:"in a sense"}),". However\nthere is no ",(0,i.jsx)(n.em,{children:"specialized"})," implementation. Let's have a look at the trait and the\ntype signature on the ",(0,i.jsx)(n.code,{children:"RefCell<T>"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// trait\npub trait BorrowMut<Borrowed>: Borrow<Borrowed>\nwhere\n    Borrowed: ?Sized,\n{\n    fn borrow_mut(&mut self) -> &mut Borrowed;\n}\n\n// \u2039RefCell<T>.borrow_mut()\u203a type signature\npub fn borrow_mut(&self) -> RefMut<'_, T>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["I think that we can definitely agree on the fact that ",(0,i.jsx)(n.code,{children:"RefMut<'_, T>"})," is not the\n",(0,i.jsx)(n.code,{children:"RefCell<T>"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"In my opinion"}),", ",(0,i.jsx)(n.code,{children:"RefCell<T>"})," implements a ",(0,i.jsx)(n.strong,{children:"separate"})," ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," rather\nthan implementing the interface, because it ",(0,i.jsx)(n.strong,{children:"cannot"})," satisfy the type requirements\nof the trait."]}),"\n",(0,i.jsx)(n.admonition,{title:"caution",type:"warning",children:(0,i.jsxs)(n.p,{children:["I wonder how are we expected to deal with this conflict, if and when, we need\nboth the ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," of the trait and ",(0,i.jsx)(n.code,{children:".borrow_mut()"})," of the ",(0,i.jsx)(n.code,{children:"RefCell<T>"}),"."]})}),"\n",(0,i.jsxs)(n.admonition,{title:"Fun fact",type:"tip",children:[(0,i.jsxs)(n.p,{children:["I was suggested by the compiler to do ",(0,i.jsx)(n.code,{children:"use std::borrow::BorrowMut;"})," and break the\ncode."]}),(0,i.jsxs)(n.p,{children:["So much for the ",(0,i.jsx)(n.em,{children:"almighty"})," and ",(0,i.jsx)(n.em,{children:"helpful"})," compiler\u2026"]})]}),"\n",(0,i.jsx)(n.h2,{id:"day-21-monkey-math",children:(0,i.jsx)(n.a,{href:"https://adventofcode.com/2022/day/21",children:"Day 21: Monkey Math"})}),"\n",(0,i.jsx)(n.admonition,{title:"tl;dr",type:"info",children:(0,i.jsx)(n.p,{children:"Computing an expression tree and then also finding ideal value for a node."})}),"\n",(0,i.jsx)(n.h3,{id:"solution-6",children:"Solution"}),"\n",(0,i.jsx)(n.p,{children:"Relatively simple, until you get to the 2nd part where you start to practice\na lot of the copy-paste. I have managed to sneak some perverted stuff in there\nthough :) Let's go through the details."}),"\n",(0,i.jsxs)(n.h4,{id:"default-trait",children:[(0,i.jsx)(n.code,{children:"Default"})," trait"]}),"\n",(0,i.jsxs)(n.p,{children:["For the first time and twice I had a need to have a default value for my types,\nenumerations in this case. Rust offers a very nice trait",(0,i.jsx)(n.sup,{children:(0,i.jsx)(n.a,{href:"#user-content-fn-1-990909",id:"user-content-fnref-1-990909","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," that is described\nas:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"A trait for giving a type a useful default value."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["I guess it sums it up nicely. The more interesting part about this is the fact\nthat you can use the ",(0,i.jsx)(n.em,{children:"macro machinery"})," to save yourself some typing. If you have\nenumeration of which the default value doesn't bear any parameter, you can just\ndo",(0,i.jsx)(n.sup,{children:(0,i.jsx)(n.a,{href:"#user-content-fn-2-990909",id:"user-content-fnref-2-990909","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"#[derive(Default)]\nenum Color {\n    #[default]\n    White,\n    Gray,\n    Black,\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"abusing-negation",children:"Abusing negation"}),"\n",(0,i.jsxs)(n.p,{children:["If you want to use a ",(0,i.jsx)(n.em,{children:"unary minus"})," operator on your own type, you can implement\na ",(0,i.jsx)(n.code,{children:"Neg"})," trait",(0,i.jsx)(n.sup,{children:(0,i.jsx)(n.a,{href:"#user-content-fn-3-990909",id:"user-content-fnref-3-990909","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),". I was dealing with a binary tree and needed a way how to look\nat the other side, so I have just implemented the negation for flipping between\nleft and right ","\ud83d\ude04"]}),"\n","\n",(0,i.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{id:"user-content-fn-1-990909",children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/std/default/trait.Default.html",children:(0,i.jsx)(n.code,{children:"Default"})})," docs ",(0,i.jsx)(n.a,{href:"#user-content-fnref-1-990909","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{id:"user-content-fn-2-990909",children:["\n",(0,i.jsxs)(n.p,{children:["Pardon my example from the graph algorithms ;) ",(0,i.jsx)(n.a,{href:"#user-content-fnref-2-990909","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{id:"user-content-fn-3-990909",children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://doc.rust-lang.org/std/ops/trait.Neg.html",children:(0,i.jsx)(n.code,{children:"Neg"})})," docs ",(0,i.jsx)(n.a,{href:"#user-content-fnref-3-990909","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var o=t(96540);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}},83591:e=>{e.exports=JSON.parse('{"permalink":"/blog/aoc-2022/3rd-week","editUrl":"https://github.com/mfocko/blog/tree/main/blog/aoc-2022/03-week-3.md","source":"@site/blog/aoc-2022/03-week-3.md","title":"3rd week of Advent of Code \'22 in Rust","description":"Surviving third week in Rust.","date":"2023-07-06T21:00:00.000Z","tags":[{"inline":true,"label":"advent-of-code","permalink":"/blog/tags/advent-of-code"},{"inline":true,"label":"advent-of-code-2022","permalink":"/blog/tags/advent-of-code-2022"},{"inline":true,"label":"rust","permalink":"/blog/tags/rust"}],"readingTime":11.57,"hasTruncateMarker":true,"authors":[{"name":"Matej Focko","email":"me+blog@mfocko.xyz","title":"a.k.a. @mf","url":"https://gitlab.com/mfocko","imageURL":"https://github.com/mfocko.png","key":"mf","page":null}],"frontMatter":{"title":"3rd week of Advent of Code \'22 in Rust","description":"Surviving third week in Rust.","date":"2023-07-06T21:00","slug":"aoc-2022/3rd-week","authors":"mf","tags":["advent-of-code","advent-of-code-2022","rust"],"hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"4th week of Advent of Code \'22 in Rust","permalink":"/blog/aoc-2022/4th-week"},"nextItem":{"title":"Sort the matrix diagonally","permalink":"/blog/leetcode/sort-diagonally"}}')}}]);